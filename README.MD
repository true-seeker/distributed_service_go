## Лабораторная работа №4 по курсу "Технологии разработки распределенных приложений"

Основной репозиторий с предыдущими
лабами [тут](https://github.com/true-seeker/distrubuted_application_university_course)
___

### Формулировка задачи

**Цель**: изучение методов коммуникации процессов в сети, а также средств динамического конфигурирования распределенных
приложений.

**Проверяемые компетенции**:

* способность работы с информацией из различных источников, включая сетевые ресурсы сети Интернет, для решения
  профессиональных задач;
* способность применять на практике теоретические основы и общие принципы разработки распределенных систем;
* уверенное знание теоретических и практических основ построения распределенных баз данных;
* способность использовать на практике стандарты сетевого взаимодействия компонент распределенной системы.

Задание выполняется в группе (не более трех студентов) или индивидуально. Каждый студент отчитывается по каждому пункту
задания индивидуально.

**Требования к выполнению работы**:

* Приложение должно обеспечивать параллельную работу нескольких клиентов и серверов. Дополнительное требование:
  возможность запуска нескольких серверов на одном компьютере.
* Клиентские приложения должны автоматически находить серверы для обслуживания и выполнения заданных функций.
* Серверы системы могут выполнять различные функции.
* При разрыве сеанса приложения должны автоматически восстанавливать свою работоспособность.
* Приложения должны поддерживать возможность взаимодействия в различных режимах.
* Для организации взаимодействия нужно использовать различные средства коммуникации (именованные каналы, мейлслоты,
  сокеты, очереди сообщений, удалённый вызов процедур, WCF-сервисы), сравнив их возможности.
  По окончании выполнения задания каждая группа студентов должна подготовить отчет.

**Отчет по выполнению задания должен включать**:

1. Общее описание приложения. Постановка задачи, введение в предметную область.
2. Архитектура системы. Обоснование выбора данного типа архитектуры распределенного приложения. Алгоритм работы
   приложения в целом.
3. Архитектура каждого из логических компонент системы (серверы, клиенты, диспетчеры). Подходы к реализации. Алгоритмы
   работы. Многопоточность, обоснование.
4. Методы коммуникаций компонентов системы (клиент→сервер, сервер→клиент и т. д.). Обоснование выбора этих методов
   коммуникации.
5. Способ передачи данных (синхронная / асинхронная, однонаправленная / двунаправленная и т. д.). Обоснование.
6. Структура передаваемых данных. Вид протоколов, обоснование выбора.
7. Отказоустойчивость системы. Как система поведет себя, если «исчезнет» один или несколько ее компонент. Что произойдет
   с системой, если «исчезнувший» компонент будет восстановлен на другом узле сети.
8. Работа с базой данных (если используется). Обоснование.
9. Исходный код приложений с комментариями.

Максимальное количество баллов, которые студент может получить за выполнение работы равно тридцати. Распределение баллов
за выполнение работы представлено в следующей таблице:

| Критерий оценивания                                                                                                                                                                                                                                                                        | Оценка |
|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------|
| Распределенное приложение спроектировано с учетом особенностей предметной области. Выбрана наиболее подходящая модель распределенной системы. Если используется распределенная база данных, то тиражирование данных имеет подходящий для данной предметной области механизм и архитектуру. | 3      |
| Архитектура системы является оптимальной для заданных при разработке критериев. В отчете присутствует обоснование выбора данного типа архитектуры.                                                                                                                                         | 3      |
| Приложение обеспечивает параллельную работу нескольких клиентов и серверов, в том числе на одном компьютере. Серверы распределенной системы выполняют различные функции.                                                                                                                   | 2      |
| Приложение является масштабируемым, позволяет добавлять новых участников взаимодействия без переписывания кода и перезапуска приложений.                                                                                                                                                   | 2      |
| Существует возможность динамического реконфигурирования системы.                                                                                                                                                                                                                           | 4      |
| Для организации взаимодействия компонент распределенной системы используется не менее четырех различных средств коммуникации. В отчете присутствует четкое обоснование выбора средств взаимодействия для каждого конкретного случая.                                                       | 4      |
| Система является отказоустойчивой. В случае если один и/или несколько компонент системы аварийно завершают свою работу.                                                                                                                                                                    | 2      |
| Распределенное приложение продолжает работать и в случае, если после аварийного завершения некоторого компонента, он восстановлен на другом узле вычислительной сети.                                                                                                                      | 3      |
| Отчет содержит подробное описание архитектуры каждого компонента распределенного приложения.                                                                                                                                                                                               | 3      |
| В отчете описана структура передаваемых данных, формат сообщений и вид протокола, используемого для этого.                                                                                                                                                                                 | 2      |
| В отчете представлено описание способа передачи сообщений при коммуникации компонентов распределенной системы с обоснованием.                                                                                                                                                              | 2      |

### Суть работы системы

___

Предметной областью была выбрана задача об укладке
рюкзака ([knapsack problem](https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%B4%D0%B0%D1%87%D0%B0_%D0%BE_%D1%80%D1%8E%D0%BA%D0%B7%D0%B0%D0%BA%D0%B5))
.

Сервер генерирует задачи с рюкзаком случайного размера и предметами со случайными весами и ценностью.

Клиент предварительно регистрируется в системе, а затем запрашивает у сервера задачу, решает ее и отправляет ответ(
максимальная найденная суммарная ценность). Общение между сервером и клиентом происходит с помощью gRPC.

Сервер, при запуске, регистрирует себя в Consul. А клиент, при запуске, обращается в Consul с запросом доступных
серверов.

Возможно поднять несколько серверов, которые будут работать вместе. Серверы складывают сгенерированные задачи в
очередь (RabbitMQ) и по запросу клиента вычитывают их из очереди

### Запуск сервера

___

Для запуска сервера необходимо запустить докер файл в папке `server`

```
docker-compose up
```

Предварительно в конфиг необходимо прописать адреса и авторизационные данные RabbitMQ, Consul и PostgreSQL

Используемые порты:

* `3333` для веб сервера
* `9876` для gRPC сервера

Эндпоинты сервера:

`GET`:

* `/healhcheck`  для проверки Консулом состояния сервера
* `/generateTask/:taskSize` для генерации случайной задачи с количеством вещей `taskSize`

### Запуск клиента

___

Варианты запуска:

1. **Собрать его из исходников**:

   В папке client:
    ```
    go build
    ```

   Предварительно необходимо сгенерировать исходники gRPC в папке gRPC командой:

    ```
    protoc --go_out=../client/backpackTaskGRPC/ --go_opt=paths=source_relative --go-grpc_out=../client/backpackTaskGRPC/ --go-grpc_opt=paths=source_relative grpc.proto
    ```

   Запустить полученный файл `client`


2. **Запустить уже собранный исполняемый файл**

   Запустить файл `client` в папке client

